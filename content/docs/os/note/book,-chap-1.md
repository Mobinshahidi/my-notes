---
title: book, chap 1
description: book, chap 1
---

## üîπ **1. What is an Operating System (OS)?**

An **Operating System (OS)** is software that sits between you and the computer hardware. It **manages the hardware**, and **provides services to programs**.

### üîß Key Responsibilities:

- **Resource allocator**: Decides which process gets which resource (CPU time, memory, etc.)
    
- **Control program**: Controls the execution of programs, prevents errors and improper use.
    

### üîÅ It handles:

- CPU (who gets to use it and when)
    
- Memory (which program gets how much)
    
- I/O devices (like your keyboard, mouse, or disk)
    
- Files and storage
    

---

## üîπ **2. Major Components of a Computer System**

A computer system is divided into **four components**:

### 1. **Hardware**

- Physical parts: CPU, RAM, hard disk, keyboard, etc.
    
- Provides **raw computing power**.
    

### 2. **Operating System**

- Controls and manages the hardware.
    
- Acts as **middleman** between the user programs and hardware.
    

### 3. **Application Programs**

- Programs users run (e.g., browser, word processor, video games).
    
- Use the OS to access hardware.
    

### 4. **Users**

- People, other systems, or applications that use the computer.
    

---

## üîπ **3. What Do Operating Systems Do (in real life)?**

### From different perspectives:

#### üî∏ Users:

- Want performance, ease of use, nice interface.
    

#### üî∏ System Managers:

- Want **efficient resource use**, security, stability.
    

#### üî∏ Embedded Systems:

- Often have **no user interface**.
    
- Focus on automation (e.g., washing machines, car computers).
    

---

## üîπ **4. OS Roles by Device Type**

|Device|OS Focus|
|---|---|
|Mainframe|Serving many users at once|
|Workstations|Performance, multitasking|
|Mobile devices|Battery life, touch input, simple|
|Servers|Stability, virtualization, speed|

---

## üîπ **5. The Operating System as a Layered Structure**

Think of it like a cake:

1. **Hardware**
    
2. **OS Kernel**
    
3. **System Programs**
    
4. **Application Programs**
    
5. **User Interface**
    

The OS provides **abstractions** so applications don‚Äôt need to deal with raw hardware directly.

---

## üîπ **6. Definitions You Should Know**

### ‚ùó Kernel

- The **core part of the OS**.
    
- Always running.
    
- Handles memory, process, and device control.
    

### üì¶ System Programs

- Utilities and services like file management, compilers, or shells.
    

### üß© Application Programs

- Programs that **do stuff for users** (like games, browsers).
    

### ‚öôÔ∏è Middleware

- Software between OS and apps (e.g., databases, game engines, APIs).
    

---

## üîπ **7. System Boot & Startup (Boot Loader)**

When you power on your computer:

1. A **bootloader** stored in ROM (firmware) runs.
    
2. It **loads the OS kernel into memory**.
    
3. OS kernel **starts executing** and takes over system control.
    

This is called the **bootstrap process**.

---

## üîπ **8. Interrupts and I/O Communication**

### What is an **Interrupt**?

- A signal to the CPU from a device (or software) that says: "Hey! I need attention!"
    
- Helps the CPU **respond to events** without constantly checking devices.
    

### Types:

- **Hardware interrupt**: From keyboard, mouse, etc.
    
- **Software interrupt / trap**: Generated by a program (e.g., divide by zero or system call).
    

### üîÅ Cycle:

1. Device signals interrupt.
    
2. CPU pauses current task.
    
3. CPU runs the **Interrupt Service Routine (ISR)**.
    
4. CPU resumes original task.
    

---

### DMA (Direct Memory Access)

- For **fast data transfer** between devices and memory.
    
- **Skips CPU involvement**, which speeds things up.
    
---

## üîπ **9. Dual-Mode Operation and Kernel vs User Mode**

### **What is Dual-Mode Operation?**

- Computers use **two different modes** of operation:
    
    1. **User Mode**: The mode where most application programs run. In this mode, a program cannot directly access hardware or memory; it is restricted.
        
    2. **Kernel Mode**: The mode where the **operating system** runs. In this mode, the OS has **full control** over the hardware and can perform any operation, including accessing memory and controlling devices.
        

### **Why do we need Dual Mode?**

- **Security and stability**: We need to ensure that user programs cannot accidentally or maliciously access or change critical parts of the system (hardware, OS resources).
    
- **Switching between modes**: This is done through a special instruction called a **system call** or **trap**.
    

#### **How Does the Mode Switch Work?**

- When a user program makes a **system call** (e.g., requesting I/O), the CPU switches from **user mode to kernel mode**.
    
- After the system call finishes, the CPU switches back to **user mode**.
    
- The **mode bit** (a hardware feature) helps distinguish between user mode and kernel mode.
    

---

## üîπ **10. System Calls and the API**

### **What is a System Call?**

A **system call** is how a program interacts with the **operating system**. It provides a controlled interface between user programs and the kernel.

**Examples of System Calls**:

- **File management**: Opening, closing, reading, writing files.
    
- **Process management**: Creating, terminating, or scheduling processes.
    
- **Device management**: Controlling devices (e.g., reading from a keyboard or writing to a disk).
    

### **What is an API?**

The **API (Application Programming Interface)** is a set of routines, protocols, and tools for building software. The **OS API** provides an interface for user programs to make system calls. For example, **POSIX** is an OS standard API for Unix-like systems.

---

## üîπ **11. Process Management**

### **What is a Process?**

- A **process** is a **program in execution**. It is an active entity that needs resources like CPU time, memory, and I/O devices to complete its task.
    

### **Key Elements of Process Management**:

- **Process creation**: The OS starts a new process.
    
- **Process scheduling**: The OS decides which process should run at a given time.
    
- **Process termination**: When the process finishes or is interrupted, it is terminated and resources are released.
    

### **Types of Processes**:

- **Single-threaded processes**: Only one thread is executing.
    
- **Multi-threaded processes**: Several threads can execute independently, sharing resources.
    

### **Concurrency and Multiprocessing**:

- Concurrency is achieved by **multiplexing** CPU time among multiple processes.
    
- On systems with **multiple CPUs**, **multiprocessing** can improve performance by running processes simultaneously.
    

### **Process Control Block (PCB)**:

- The OS uses a **PCB** to track process states, including registers, program counter, and memory used.
    

---

## üîπ **12. Scheduling Algorithms**

### **CPU Scheduling**:

- When multiple processes are ready to run, the **scheduler** determines which one to run next.
    
- Common scheduling algorithms:
    
    - **First-Come, First-Served (FCFS)**
        
    - **Shortest Job Next (SJN)**
        
    - **Round Robin (RR)**
        
    - **Priority Scheduling**
        

### **Context Switching**:

- Switching between processes requires saving the state of the current process and loading the state of the next process.
    
- **Context switch time** is a performance consideration for the OS.
    

---

## üîπ **13. Memory Management**

### **Why Memory Management?**

- The OS must decide **what memory** (RAM) is allocated to which process, and when processes should be moved in/out of memory.
    

### **Key Tasks**:

- **Tracking memory usage**: The OS keeps track of which parts of memory are being used.
    
- **Swapping**: When the system runs low on memory, it may move processes in and out of memory (swap them).
    

### **Memory Allocation Techniques**:

- **Contiguous Allocation**: A process is allocated a contiguous block of memory.
    
- **Paged Memory**: Memory is divided into small fixed-size pages to avoid fragmentation.
    
- **Segmented Memory**: Memory is divided into variable-sized segments.
    

---

## üîπ **14. File-System Management**

### **What is File-System Management?**

- The OS provides a **uniform view of storage** using files (abstraction of storage).
    
- It hides the complexities of the underlying hardware (like disks, tapes) and provides a logical file structure (directories, file paths).
    

### **Key Functions**:

- **File creation and deletion**: The OS allows programs to create, open, and delete files.
    
- **File manipulation**: OS provides system calls for reading, writing, and modifying files.
    
- **Directory management**: The OS maintains a directory structure for storing files.
    
- **Access control**: OS enforces permissions, determining who can read or modify a file.
    

---

## üîπ **15. I/O Management**

### **What is I/O Management?**

- The OS manages all **input/output devices**, like keyboards, displays, and disk drives.
    
- It abstracts away the details of different devices and provides a **unified interface** for programs.
    

### **Buffering and Caching**:

- **Buffering** stores data temporarily while it is being transferred.
    
- **Caching** stores frequently accessed data in faster memory to improve performance.
    

---

## üîπ **16. Protection and Security**

### **Protection**:

- Protection is about **controlling access** to system resources (files, memory, devices) and ensuring that processes do not interfere with each other.
    

### **Security**:

- Security involves defending against **internal and external threats** like viruses, worms, and unauthorized access.
    

### **Key Mechanisms**:

- **User authentication**: Verifying user identity using passwords or biometric data.
    
- **Access control**: Ensuring that users have the appropriate permissions for files or resources.
    

---

## üîπ **17. Virtualization**

### **What is Virtualization?**

- Virtualization allows the OS to run **multiple virtual machines (VMs)** on a single physical machine.
    
- Each VM runs its own OS and behaves like an independent system.
    

### **Use Cases**:

- Running multiple OSes on a single machine.
    
- Testing software in different environments without needing separate hardware.
    

---

## üîπ **18. Distributed Systems**

### **What is a Distributed System?**

- A **distributed system** is a collection of independent systems that communicate over a network to achieve a common goal.
    
- Examples include cloud computing, file-sharing networks, and web applications.
    

### **Key Components**:

- **Networking**: The systems are interconnected via a network (LAN, WAN).
    
- **Distributed OS**: OS that manages the resources of the distributed system, giving the illusion of a single system.
    

---

## **Final Summary of Chapter 1:**

In this chapter, we learned about the **fundamentals of operating systems**, including their **core responsibilities** (resource allocation, control), the **structure** of a computer system (hardware, OS, applications, and users), and **how the OS manages processes, memory, files, and I/O devices**.

### **Main Takeaways**:

1. **OS functions**: Resource management, process control, memory management, I/O management, security, etc.
    
2. **Kernel vs. User Mode**: Differentiates between code with full system access and user-level applications.
    
3. **Process management**: Scheduling, creating, and terminating processes.
    
4. **Memory management**: Ensures efficient use of RAM, handles swapping and paging.
    
5. **File-system management**: Deals with storing, retrieving, and organizing data.
    
6. **Security & Protection**: Protects system resources from unauthorized access.
    

---

## **Final summary book:** 

‚Ä¢ An operating system is software that manages the computer hardware, as  
well as providing an environment for application programs to run.  
‚Ä¢ Interrupts are a key way in which hardware interacts with the operating  
system. A hardware device triggers an interrupt by sending a signal to the  
CPU to alert the CPU that some event requires attention. The interrupt is  
managed by the interrupt handler.  
‚Ä¢ For a computer to do its job of executing programs, the programs must be  
in main memory, which is the only large storage area that the processor  
can access directly.  
‚Ä¢ The main memory is usually a volatile storage device that loses its contents  
when power is turned off or lost.
‚Ä¢ Nonvolatile storage is an extension of main memory and is capable of  
holding large quantities of data permanently.  
‚Ä¢ The most common nonvolatile storage device is a hard disk, which can  
provide storage of both programs and data.  
‚Ä¢ The wide variety of storage systems in a computer system can be organized  
in a hierarchy according to speed and cost. The higher levels are expensive,  
but they are fast. As we move down the hierarchy, the cost per bit generally  
decreases, whereas the access time generally increases.  
‚Ä¢ Modern computer architectures are multiprocessor systems in which each  
CPU contains several computing cores.  
‚Ä¢ To best utilize the CPU, modern operating systems employ multiprogramming, which allows several jobs to be in memory at the same time, thus  
ensuring that the CPU always has a job to execute.  
‚Ä¢ Multitasking is an extension of multiprogramming wherein CPU scheduling algorithms rapidly switch between processes, providing users with a  
fast response time.  
‚Ä¢ To prevent user programs from interfering with the proper operation of  
the system, the system hardware has two modes: user mode and kernel  
mode.  
‚Ä¢ Various instructions are privileged and can be executed only in kernel  
mode. Examples include the instruction to switch to kernel mode, I/O  
control, timer management, and interrupt management.  
‚Ä¢ A process is the fundamental unit of work in an operating system. Process management includes creating and deleting processes and providing  
mechanisms for processes to communicate and synchronize with each  
other.  
‚Ä¢ An operating system manages memory by keeping track of what parts of  
memory are being used and by whom. It is also responsible for dynamically allocating and freeing memory space.  
‚Ä¢ Storage space is managed by the operating system; this includes providing  
file systems for representing files and directories and managing space on  
mass-storage devices.  
‚Ä¢ Operating systems provide mechanisms for protecting and securing the  
operating system and users. Protection measures control the access of  
processes or users to the resources made available by the computer system.  
‚Ä¢ Virtualization involves abstracting a computer‚Äôs hardware into several  
different execution environments.  
‚Ä¢ Data structures that are used in an operating system include lists, stacks,  
queues, trees, and maps.  
‚Ä¢ Computing takes place in a variety of environments, including traditional  
computing, mobile computing, client‚Äìserver systems, peer-to-peer systems, cloud computing, and real-time embedded systems.
‚Ä¢ Free and open-source operating systems are available in source-code format. Free software is licensed to allow no-cost use, redistribution, and  
modification. GNU/Linux, Free BSD , and Solaris are examples of popular  
open-source systems.